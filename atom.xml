<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JuMi&#39;blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-02T02:42:32.196Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SnoppDogg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网</title>
    <link href="http://example.com/2022/07/02/%E8%AE%A1%E7%BD%91/"/>
    <id>http://example.com/2022/07/02/%E8%AE%A1%E7%BD%91/</id>
    <published>2022-07-02T02:34:58.000Z</published>
    <updated>2022-07-02T02:42:32.196Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.流量强度的公式，当其值趋近于0、1和&gt;1时，排队时延如何？</strong></p><p>​            流量强度公式为    ：<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BLa%7D%7BR%7D" alt="[公式]"></p><ul><li>&#96;&#96;&#96;<br> R：链路带宽；L：分组长度；a：平均分组到达速率<ul><li>​            趋于0，则排队时延较小    </li><li>​            趋于1，则很大</li><li>​            大于1，时延延迟无限大<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**2.N个客户端下载文件，对于CS和P2P需要多少时间？**</span><br><span class="line"></span><br></pre></td></tr></table></figure>如果CS架构，把文件（F大小）上传到服务器时间d1，服务器向N个客户端下载(速度u)需要N*F&#x2F;u，这是串行的，时间随客户端数量线性增长。</li></ul></li></ul><p>如果P2P架构，把文件（F大小）上传到服务器时间d1，服务器向N个客户端下载(速度u)需要N*F&#x2F;u，但客户端相互之间可以分发，是并行的，速度肯定要快，不会随客户端数量线性增长。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20220702103203480](https://s2.loli.net/2022/07/02/RF3cbSCvYIa6BEl.png)</span><br><span class="line"></span><br><span class="line">![image-20220702103231226](https://s2.loli.net/2022/07/02/3gPNUGLh96DmCuo.png)</span><br><span class="line"></span><br><span class="line">**3.简述RDT2.0、2.1、2.2和3.0.**</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    RDT1.0 理想的信道，不丢包，不出错 发送⽅就发，接受发就接，双⽅不需要交互     </code></pre><hr><h2 id="​-RDT2-0-出错（checksum），不丢包，-接受⽅回复ACK或者NAK，发送⽅收到NAK重传-只考虑发送⽅的数据包是否出错，没有考虑回复信息是否出错"><a href="#​-RDT2-0-出错（checksum），不丢包，-接受⽅回复ACK或者NAK，发送⽅收到NAK重传-只考虑发送⽅的数据包是否出错，没有考虑回复信息是否出错" class="headerlink" title="​        RDT2.0 出错（checksum），不丢包， 接受⽅回复ACK或者NAK，发送⽅收到NAK重传 只考虑发送⽅的数据包是否出错，没有考虑回复信息是否出错 "></a>​        RDT2.0 出错（checksum），不丢包， 接受⽅回复ACK或者NAK，发送⽅收到NAK重传 只考虑发送⽅的数据包是否出错，没有考虑回复信息是否出错 </h2><p>​        RDT2.1 出错（checksum），不丢包 接受房回复ACK或者NAK，接受⽅收到NAK重传 发送⽅的数据包是否出错，也要考虑回复信息是否出错 发送饭收到⼀个出错的回复，重传，有可能在接受⽅造成重复，为了解决重复， 加编号 ———————————————————————————————————<br>​        RDT2.2 出错（checksum），不丢包 不使⽤NAK，出错就发送以前的ACK 接收⽅收到重复的ACK，代表否定信息，重传 ———————————————————————————————————<br>​        RDT3.0 出错（dchecksum），丢包（靠计时器解决） 如果丢包，发送⽅接受不到任何信息 加上计时器，超时重传 3.0是 正确的（功能上没有问题，但是性能太差）</p><hr><h2 id="​-流⽔线⼯作⽅式-go-back-N-允许连续发送N个未被确认的包-接受⽅采⽤累计确认，ACK（N）代表n号包以及n以前的包都正确接受-单⼀的计时器，为最早的发送的未被确认的包计时-如果超时，timeout（n）n号包以及n以后的已经发送的包都要重传-在接受⽅不缓存乱序的包，如果乱序的话就丢弃"><a href="#​-流⽔线⼯作⽅式-go-back-N-允许连续发送N个未被确认的包-接受⽅采⽤累计确认，ACK（N）代表n号包以及n以前的包都正确接受-单⼀的计时器，为最早的发送的未被确认的包计时-如果超时，timeout（n）n号包以及n以后的已经发送的包都要重传-在接受⽅不缓存乱序的包，如果乱序的话就丢弃" class="headerlink" title="​        流⽔线⼯作⽅式 go-back-N 允许连续发送N个未被确认的包 接受⽅采⽤累计确认，ACK（N）代表n号包以及n以前的包都正确接受 单⼀的计时器，为最早的发送的未被确认的包计时 如果超时，timeout（n）n号包以及n以后的已经发送的包都要重传 在接受⽅不缓存乱序的包，如果乱序的话就丢弃"></a>​        流⽔线⼯作⽅式 go-back-N 允许连续发送N个未被确认的包 接受⽅采⽤累计确认，ACK（N）代表n号包以及n以前的包都正确接受 单⼀的计时器，为最早的发送的未被确认的包计时 如果超时，timeout（n）n号包以及n以后的已经发送的包都要重传 在接受⽅不缓存乱序的包，如果乱序的话就丢弃</h2><p>​        选择重传 允许连续发送N个未被确认的包 接受⽅采⽤单独确认，ACK（n）仅代表n号包被正确接受 采⽤多个计时器，为每个发送的未被确认的包计时 如果超时，timeout（n），仅仅重传n号包 在接受⽅缓存乱序的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**4.拥塞窗口的变化，看图分析出超时、三个重复ACK、阈值、拥塞窗口大小、拥塞避免阶段和慢启动阶段。**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1，慢启动阶段（slow start）：拥塞窗⼝（cwnd）值为1MSS，每当传输报⽂段⾸次被确认就增加1MSS，并且发送出原来两倍的报⽂段，第⼆次确认后cwnd增加2MSS，所以这个阶段每过⼀个RTT拥塞窗⼝翻倍，发送速率就会翻倍。成指数增⻓。 为了防⽌cwnd增⻓过⼤引起⽹络拥塞，还需设置⼀个慢开始⻔限ssthresh状态变量。 </p><p>2，拥塞避免阶段（congestion avoidance）：当cwnd&gt;ssthresh时，改⽤拥塞避免算法，让拥塞窗⼝缓慢增⻓，即每经过⼀个往返时间RTT就把发送⽅的拥塞窗⼝cwnd加1，⽽不是加倍。这样拥塞窗⼝按线性规律缓慢增⻓。 </p><p>3，快速恢复阶段（fast recovery）：论是在慢开始阶段还是在拥塞避免阶段，只要发送⽅判断⽹络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为⽆法判定，所以都当做拥塞来处理），就把慢开始⻔限设置为出现拥塞时的发送窗⼝⼤⼩的⼀半。然后把拥塞窗⼝设置为1，执⾏慢开始算法。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://s2.loli.net/2022/07/02/wLKbjha6ioe4vY3.jpg)</span><br><span class="line"></span><br><span class="line">![img](https://s2.loli.net/2022/07/02/bVz3Loh967vky1g.jpg)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当CWin低于Threshold时，发送方在慢启动阶段，窗口以指数形式增长；</p><p>当CWin高于Threshold时，发送方在拥塞避免阶段，窗口线性增长；</p><p>当出现三个ACK时，CWin降为发生拥塞前CWin&#x2F;2，开始线性增长；</p><p>当出现超时时，Threshold将为发生拥塞前的一半，CWin的起始值为1MSS，开始慢启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**5.为什么需要数据报网络和虚电路网络（VC）**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一、数据报（datagram）<br>​在Internet中使用数据报，在计算机之间交换数据：“弹性服务”,无严格的定时要求（strict timing req）<br>​许多的链路模型拥有不同的特点，难以提供统一的服务<br>​智能的端系统能够适应执行控制、差错控制、达到了网络内部简单，“边缘”复杂的设计效果<br>二、虚电路网络（VC）<br>​从电话技术演变而来<br>​严格定时，并有可靠性要求，有对确保服务的要求<br>​简单的端系统网络内部复杂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220701105250638](https://s2.loli.net/2022/07/02/RLGXc3TW5K7o6Ba.png)</span><br><span class="line"></span><br><span class="line">**6.子网划分，给子公司或部门划分网络。**</span><br><span class="line"></span><br><span class="line">![image-20220701113240922](https://s2.loli.net/2022/07/02/4xItTiKgnlsjf2R.png)</span><br><span class="line"></span><br><span class="line">```tex</span><br><span class="line">子网掩码的计算步骤：</span><br><span class="line">1、确定要划分的子网数目以及每个子网的主机数目。 </span><br><span class="line">2、求出子网数目对应二进制数的位数N及主机数目对应二进制数的位数M。 </span><br><span class="line">3、对该IP地址的原子网掩码，将其主机地址部分的前N位置 1或后M位置0 即得出该IP地址划分子网后的子网掩码。</span><br><span class="line">Example：</span><br><span class="line">对B类网络135.41.0.0/16需要划分为20个能容纳200台主机的网络。</span><br><span class="line">因为16＜20＜32，所以，子网位只须占用5位主机位就可划分成32个子网，可以满足划分成20个子网的要求。B类网络的默认子网掩码是255.255.0.0，</span><br><span class="line">二进制为11111111.11111111.00000000.00000000</span><br><span class="line">现在子网又占用了5位主机位，划分子网后的子网掩码应该为</span><br><span class="line">      11111111.11111111.11111000.00000000</span><br><span class="line">转换为十进制应该为255.255.248.0</span><br><span class="line">现在我们再来看一看每个子网的主机数。</span><br><span class="line">子网中可用主机位还有11位，2的11次方＝2048，去掉主机位全0和全1的情况，还有2046个主机ID可以分配，而子网能容纳200台主机就能满足需求，按照上述方式划分子网，每个子网能容纳的子网数目远大于需求的主机数目，造成了IP地址资源的浪费。</span><br><span class="line">为了更有效地利用资源，我们也可以根据子网所需主机数来划分子网。还以上例来说，128＜200＜256，即2^7＜200＜2^8，也就是说，在B类网络的16位主机位中,保留8位主机位，其它的16－8＝8位当成子网位，可以将B类网络138. 96.0.0划分成256(2^8)个能容纳256－1－1－1=253台（去掉全0全1情况和留给路由器的地址）主机的子网。此时的子网掩码为11111111.11111111.11111111.00000000，转换为十进制为255.255.255.0。 </span><br><span class="line"></span><br><span class="line">快速划分子网确定IP</span><br><span class="line">    我们以例2为例： 题目需要我们将192.168.5.0/24这个网络地址划分成能容纳101/54/2个主机的子网。因此我们要先确定主机位，然后根据主机位决定网络位，最后确定详细的IP地址。</span><br><span class="line">    ① 确定主机位</span><br><span class="line">    将所需要的主机数自大而小的排列出来：101/54/2，然后根据网络拥有的IP数目确定每个子网的主机位：如果2的n次方-2≥该网段的IP数目，那么主机位就等于n。于是，得到：7/6/2。</span><br><span class="line">    ② 根据主机位决定网络位</span><br><span class="line">    用32减去主机位剩下的数值就是网络位，得到：25/26/30。</span><br><span class="line">    ③ 确定详细的IP地址</span><br><span class="line">    在二进制中用网络位数值掩盖IP前面相应的位数，然后后面的为IP位。选取每个子网的第一个IP为网络地址，最后一个为广播地址，之间的为有效IP。得到：</span><br><span class="line">【网络地址】       【有效IP】                           【广播地址】</span><br><span class="line">【192.168.5.0/25】    【192.168.5.1/25-192.168.5.126/25】  【192.168.5.127/25】</span><br><span class="line">【192.168.5.128/26】  【192.168.5.129/26-192.168.5.190/26】  【192.168.5.191/26】</span><br><span class="line">【192.168.5.192/30】  【192.168.5.193/30-192.168.5.194/30】【192.168.5.195/30】 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>7.链路状态算法、计算从某个节点到其他节点的最短距离。</strong></p><p><img src="https://s2.loli.net/2022/07/02/ikaBMHmdDAy3YS6.png" alt="image-20220701114247177"></p><p><strong>8.简述CSMA</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">载波侦听多路访问协议（CSMA）：</span><br><span class="line">CS：载波监听</span><br><span class="line">MA:多点接入</span><br><span class="line">CSMA（先听再发）：发送之前，先监听信道，先听后发，一个信号结点的传播时延越长，载波侦听结点不能侦听到网络中另一个结点已经开始传输的机会就越大，没有碰撞检测，即使出现碰撞也完整传输他们的帧</span><br></pre></td></tr></table></figure><p><strong>9.简述CSMA&#x2F;CD</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSMA/CD：无时隙，（先听再发，边听边发，冲突停发，随机重发）：先听后发，边发边听，碰撞后及时停止传输，等待一段随机的时间再进行重传。</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/w6mZct1iTWHnMCf.png" alt="image-20220701154621774">10.当访问某个网页，网络内部是如何工作的？参考第五章第七节课件。</p><p><img src="https://s2.loli.net/2022/07/02/vENJ6Mf5BYHaeQb.png" alt="image-20220702091906752"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/GwNMFAcoThvrLu8.png" alt="image-20220702091919231"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">校园网----&gt;DNS server-----&gt;google</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/2XrzNkijhUgD5P1.png" alt="  "></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、连接笔记本电脑需要获取他的IP，他第一跳的路由（IP address）默认网关、DNS server的地址</span><br><span class="line">DHCP(报文)---&gt;UDP(传输层：报文段)---&gt;IP（网络层：数据报） ---&gt;Eth（802.3 以太网的帧）---&gt;phy</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/iGy6HXaotgqkWRO.png" alt="image-20220702092025263"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、收到后进行DHCP的应答，回复DHCP ACK 包括IP地址、第一跳路由的地址、DNS server的地址，一层层封装，经过交换机，客户端收到DHCP ACK，届时笔记本可以连上网络</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/oOfGuNr6ywihjS4.png" alt="image-20220702092032181"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3、在进行HTTP request之前，需要对Google的域名进行DNS查询，与前面类同，主机和DNS　server不在同一个局域网,需要经过路由器对外进行访问,主机和路由器在同一个端口里面,需要路由的MAC地址，进行ARP查询，回复MAC地址</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/yom6wskfteajbHK.png" alt="image-20220702092041194"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4、向外去走,需要自治系统内或者自治系统间的转发表生成,到达DNS　Server后,DNS进行回复，回复Google的IＰ地址</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/6zJHLUwqWYhKM1p.png" alt="image-20220702092048518"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.客户端收到IP地址后,发送HTTP请求,三次握手:</span><br><span class="line">客户端先发一个SYN的报文段,服务器收到以后,给一个SYNACK的应答,客户端收到以后,tcp连接建立</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/HzbLwUjavWnrEPu.png" alt="image-20220702092058761"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.发送http request,服务器收到后发送HTTP reply(包括网页) </span><br></pre></td></tr></table></figure><p><strong>11.CDMA的编码和解码。</strong></p><p><img src="https://s2.loli.net/2022/07/02/NnHwLXiKaBuOy4l.png" alt="image-20220702102020538"></p><p><strong>12.TCP可靠传输中ack（n)的含义。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/02/JSa1nwxyPVRiodQ.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：客户端首先向服务器发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户端会随机选择一个起始号seq=x(连接请求报文不携带数据，但要消耗掉一个序号)。客户端进程进入SYN_SENT（同步发送）状态。 </span><br><span class="line"></span><br><span class="line">第二次握手：服务器收到连接请求报文段后，如同意建立连接，就向客户端发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq=y(确认报文不携带数据，但也要消耗掉一个序号)。确认报文段同样不包含应用层数据。服务端进入SYN_RCVD（同步接收）状态。</span><br><span class="line"></span><br><span class="line">第三次握手：当客户端收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置为1，序号字段为x+1，确认号字段为ack=y+1。该报文可以携带数据，如果不携带数据则不消耗序号。客户端进入ESTABLISHED（建立连接）状态。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>13.时间槽ALOHA</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间槽ALOHA:各个节点时钟同步（非常困难），每个节点发送数据必须在时间槽起始位置发送</span><br><span class="line">纯ALOHA:    各个节点时钟不需要同步，节点来了数据就发送和　　０.１８</span><br><span class="line">CSMA/: 载波监听多址访问，发前先听，如果信道忙推迟发送；如果是闲的立即发送整个帧，冲突也要发送完，浪费信道CSMA/CD:载波监听多址访问，发前先听，如果信道忙推迟发送；如果是闲的立即发送整个帧，边听边发，节省信道</span><br></pre></td></tr></table></figure><p><strong>14.列举几种有导和无导的传输媒体。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，有导媒体（guided media）：双绞线（copper），同轴电缆（coax），光纤(fiber)</span><br><span class="line">2，无导媒体（unguided media）：无限电波，微波(microwave)，红外线，激光卫星（satellite），WIFI</span><br></pre></td></tr></table></figure><p><strong>15.FTP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FTP在传输层使用TCP协议</span><br><span class="line">控制连接（control connection） 传输控制信息（用户标识，命令）端口号21</span><br><span class="line">数据连接（data connection） 传输文件 端口号20</span><br></pre></td></tr></table></figure><p><strong>16.进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip+port标识一个进程?</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.流量强度的公式，当其值趋近于0、1和&amp;gt;1时，排队时延如何？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​            流量强度公式为    ：&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Raft源码分析，让Raft变得简单</title>
    <link href="http://example.com/2022/05/28/Raft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/05/28/Raft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-05-28T11:31:50.000Z</published>
    <updated>2022-05-28T11:47:37.632Z</updated>
    
    <content type="html"><![CDATA[<p>​        前一些日子在家，老师给的一个paper是关于一致性协议的，读了源码，为了了解更深一点，所以一知半解的去刷了MIT的分布式系统的公开课，而Raft 在 HyperLedger也有应用，暂且先开一个帖子，,等不忙了会补全。</p><p>​        在学术理论界，分布式一致性算法的代表还是Paxos。但是少数理解的人觉得很简单，尚未理解的觉得很难，大多数人还是一知半解。Paxos的可理解性和工程落地性的门槛很高。斯坦福学者也花了很多时间理解Paxos，于是他们又研究出Raft作为一种类Paxo算法。</p><p>Raft将共识问题分解三个子问题：</p><ul><li><strong>Leader election 领导选举</strong>：有且仅有一个leader节点，如果leader宕机，通过选举机制选出新的leader；</li><li><strong>Log replication 日志复制</strong>：leader从客户端接收数据更新&#x2F;删除请求，然后日志复制到follower节点，从而保证集群数据的一致性；</li><li><strong>Safety 安全性</strong>：通过安全性原则来处理一些特殊case，保证Raft算法的完备性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        前一些日子在家，老师给的一个paper是关于一致性协议的，读了源码，为了了解更深一点，所以一知半解的去刷了MIT的分布式系统的公开课，而Raft 在 HyperLedger也有应用，暂且先开一个帖子，,等不忙了会补全。&lt;/p&gt;
&lt;p&gt;​        在学</summary>
      
    
    
    
    
    <category term="Fabric" scheme="http://example.com/tags/Fabric/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Raft" scheme="http://example.com/tags/Raft/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>sGuard漏洞修复</title>
    <link href="http://example.com/2022/05/28/sGuard%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/"/>
    <id>http://example.com/2022/05/28/sGuard%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/</id>
    <published>2022-05-28T11:25:26.000Z</published>
    <updated>2022-05-28T12:29:49.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUARD：智能合约的漏洞检测及其修复"><a href="#GUARD：智能合约的漏洞检测及其修复" class="headerlink" title="GUARD：智能合约的漏洞检测及其修复"></a>GUARD：智能合约的漏洞检测及其修复</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ol><li><p>验证和测试是避免合约漏洞的现如今的两个主要方向，SGUARD受启发于程序修复技术（program fixing techniques）Github:<a href="https://github.com/duytai/sGuard">https://github.com/duytai/sGuard</a></p></li><li><p>大体分为两步</p><ol><li>收集一个有限的象征性执行集合（symbolic execution traces），对其进行静态分析，判断是否存在潜在漏洞，SGURAD现在能够支持检测修复四种常见漏洞。SGUARD的静态分析引擎是从零开始构建的，现存安全分析工具对于SGURAD来说是不可行的</li><li>对每一种SGUARD支持的漏洞对其源代码都有特定的修复模式，在终止时也是完整健全的</li></ol></li><li><p>contribution：</p><ol><li><p>提供了支持四种智能合约的漏洞，对其进行自我修复</p></li><li><p>证明了方法是完整健全的</p></li><li><p>对5000份进行评估修复，修复1605份，修复时间和gas花销都是较小的</p></li></ol></li></ol><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><ol><li><p>根据字节码对漏洞进行检测，基于源代码对合约进行修复</p></li><li><p>修补过程对所有的算术操作都被能够安全执行相应操作的函数所调用或者取代，防止出现一些漏洞</p></li><li><p>SGUARD不要求修复的规格来自用户，将会限制在实践中的通用性，为此SGUARD总是保守的假设所有可能导致漏洞的算术溢出都是有问题的，虽然补丁代价不是最小的，但保证补丁传输代理没有算术漏洞，由此产生的智能合约没有算术漏洞和再现漏洞</p><hr><p><img src="https://s2.loli.net/2022/05/28/P1psgkFzr5ZdGBC.png" alt="image-20220528191802592"></p><h1 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h1><ol><li><p>每个操作码都静态分配了唯一的一个程序计数器，保证了每个操作码都可以更具程序计数器进行唯一识别。</p></li><li><p>var包括堆栈变量、内存变量、存储变量，堆栈和内存变量都是易失性的，在每次交易前都会被清除，被视为局部变量，存储变量是非易失性的，在区块链上持久存在，一起在特定的值下确定智能合约的状态，为合同级变量</p></li><li><p>合约执行会生成只能合同的符号痕迹，在外部呼叫的情况下，不是将当前执行上下文切换到另外一个只能智能合同，简化利用符号值来表示外部呼叫的返回值</p><p><img src="https://s1.328888.xyz/2022/05/28/tTMJS.png" alt="image-20220528191839498"></p></li><li><p>Definitions</p></li><li><ol><li><p>控制依赖性（Control dependency)：某一个操作要想执行，必须依赖于前面的某一个硬性操作哦，所有迹线都必须通过。</p><p><img src="https://s1.328888.xyz/2022/05/28/tTP3J.png" alt="image-20220528191931153"></p></li><li><p>数据依赖性（Data dependency）：堆栈变量、内存变量、存储变量</p><p><img src="https://s1.328888.xyz/2022/05/28/tc8R7.png" alt="image-20220528191937113"></p></li><li><p>可重入式漏洞</p><p><img src="https://s1.328888.xyz/2022/05/28/tc4LZ.png" alt="image-20220528191945853"></p></li><li><p>跨函数可重入漏洞</p></li><li><p><img src="https://s1.328888.xyz/2022/05/28/tcHCC.png" alt="image-20220528191952459"></p></li><li><p>tx.orgin漏洞：错误的以太传输不可逆转的</p></li><li><p><img src="https://s1.328888.xyz/2022/05/28/tcdu1.png" alt="image-20220528191957600"></p><p><img src="https://s1.328888.xyz/2022/05/28/tc5EO.png" alt="image-20220528192003594"></p></li></ol></li><li><p>construct一个智能合同满足条件是：（1和2是关于建设的正确性，3是关于计算gas开销的正确性）</p><ol><li><p>T无任何一个上述漏洞</p></li><li><p>每个符号跟踪，若不存在任何楼哦对那个损失，鉴于相同的输入，应该产生相同的输出和状态</p></li><li><p>T的执行速度和gas的消耗速度应该相差很小</p><img src="https://s2.loli.net/2022/05/28/9WYvwCTiP4pgyRU.png" alt="image-20211125204258935" style="zoom:80%;" /><hr><h1 id="Detailed-Approach"><a href="#Detailed-Approach" class="headerlink" title="Detailed Approach"></a>Detailed Approach</h1><ol><li><p>精确识别控制依赖和数据依赖是精确识别漏洞的先决条件</p></li><li><p>一种是识别漏洞方法是通过过度近似的静态分析，基于SGURAD的设置，一旦漏洞被识别，通过引入额外的运行时间来修复它，其次，现有方法也会不完整，不能够捕获所有依赖，第三，若重写系统在没有任何结果的情况下终止，分析结果可能没有什么作响，在该系统中始终以一种涵盖高精度的所有依赖以正确的结果终止</p></li><li><p>算法细节</p><ol><li><p>系统的枚举具有象征性的跟踪，最多可为每个循环迭代的某些阈值数量</p></li><li><p>每一条symbolic trace都被检查，来判断是否更具我们的定义隶属于确定的漏洞</p></li><li><p>相应的基于AST的源代码漏洞被识别和修复</p><p><img src="https://s2.loli.net/2022/05/28/SbDiPk2MFYgyGtA.png" alt="image-20220528192018651"></p></li></ol></li><li><p>概述：首先识别循环头，bound（n）代表我们收集的符号踪迹的被访问的次数，bound(n)是根据在该循坏体内的分支语句和赋值语句的数量，相当于就是说反向遍历循环体，从结束循环的节点到n，每单个执行路径维护一个bound（数值为在该条路径下赋值语句的数量），若该单个执行路径存在有分支语句（branch）则设置一个新bound，每个节点的bound是根据（fixed-point algorithm）<a href="https://blog.csdn.net/weixin_42765703/article/details/101980875">不动点 </a>进行计算的，如果一旦计算出来bounds的值，我们便系统列举所有最大符号跟踪数量， 即循环头（n）最多也被访问n次，通过这个过程来看是否总是会终止并返回一组symbolic traces。SGURAD保证了使用bound不会错过4种漏洞的任何一种。</p></li><li><p>查看所有依赖关系显示在我们收集的symbolic traces中，我们区分了两种状况，所有的控制依赖在分支执行时都会被识别出来，这是基于上面提到的收集symbolic traces的方法，该方法同时也适用于不属于任何循环的数据依赖。</p></li><li><p>循环路径执行会遇到路径过多。SGUARD在探索符号路径是指数级的，工具会默认设置一个k值，当K大的时候会导致路径爆炸的问题，而K小的时候会导致错误的阴性结果，SGUARD自动为每个循环确定一个循环界限。</p></li><li><p>为了系统识别所有控制依赖关系，SGUARD构造了一个控制流图，利用WorkList algorithm建立了一个基于（CFG）control flow graph的<a href="https://blog.csdn.net/dashuniuniu/article/details/52224882">后支配树</a>。</p><p><img src="https://s2.loli.net/2022/05/28/ZpyzckbJY2Kuire.png" alt="image-20220528192052739"></p></li></ol><p><img src="https://s2.loli.net/2022/05/28/bsp8uUVYNrnl9i5.png" alt="image-20220528192059254"></p><ol><li><p>对数据的依赖更为复杂，跟踪数据源上的数据流，以获取数据依赖性，数据通过MSTORE从堆栈流到内存，通过MLOAD从内存流到堆栈，通过SSTORE从堆栈流到存储，通过SLOAD从存储流到堆栈。由于只有数据赋值操作会产生属于据依赖，级上述的三种过程，设计的一种基于symbolic traces的赋值操作码来识别数据依赖。</p></li><li><p>合约修复的一般步骤：</p><ol><li><p>给定一个symbolic traces，必须存在一些其他OPc的依赖的操作码操作，基本思想是在操作前引入运行时检查，以防止漏洞，根据漏洞的类型，运行时检查的注入有如下：</p><ol><li><p>在一个包含op操作的函数F中添加了一个修饰符，防止函数(intra-function)内部的可重入漏洞，组织攻击者重新进入F;为了防止（cross-function）的重入漏洞，同样也添加了修饰符，细节在Algorithm 4有所体现。 </p><img src="https://s2.loli.net/2022/05/28/oTY79kEvjlugm2q.png" alt="image-20211125192211628" style="zoom:80%;" /></li><li><p>为了修复<a href="https://ssr-zjm.github.io/2020/05/04/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1-tx.origin%E6%BC%8F%E6%B4%9E.html">tx.origin</a>漏洞，将op（ORIGIN）替换为msg.sender为调用该函数的直接账户的地址</p></li><li><p>为了修复算数漏洞，将一些op操作替换为对安全函数的调用，在执行算数操作之前检查overflow&#x2F;underflow</p></li></ol></li><li><p>需要注意的，在有reentrancy vulnerability 和 arithmetic vulnerability的情况下，如果运行时检查失败，交易将立即回复执行前的状态，从而防止漏洞，即使已有gas被花费。</p></li></ol></li><li><p>Theorem（定理）</p><ol><li><p>Algorithm 1修复的智能合同没有<strong>intra-function reentrancy vulnerability, cross-function reentrancy vulnerability, dangerous tx.origin vulnerability, and arithmetic vulnerability</strong>漏洞，Proof:给定一个智能合约S，若有漏洞，SGUARD至少识别其中之一</p><p><img src="https://s2.loli.net/2022/05/28/CXVdlBo1Y6cqgRy.png" alt="image-20211125193849038"></p><hr><h1 id="IMPLEMENTATION-AND-EVALUATION"><a href="#IMPLEMENTATION-AND-EVALUATION" class="headerlink" title="IMPLEMENTATION AND EVALUATION"></a>IMPLEMENTATION AND EVALUATION</h1><p>Emplement and Evaluation</p></li></ol></li><li><p>node.js实现，字节码用来检测 可重入性，而source-map和AST用来修复原代码级别的智能合约，source-map将OPcode映射到statement当中，再将statement连接到AST的节点中，以上来完全控制和修复智能合约。</p></li><li><p>SGUARD的实施还必须处理多种复杂问题</p><ol><li>Solidity允许开发人员利用EVM虚拟机的OPcode来交织代码，允许一些详细深入的控制，也为漏洞发掘打开了新的一扇门。决定将OPcode 引入内联汇编中。？？？</li><li>用多种启发式的方式来避免无用的修复，例如：给定一个算术表法式，有具体值的操作数（比如用户输入等），SGUARD就不会用安全数学的表达式去替换，由于每个循坏要展开的迭代次数取决于赋值语句的数量，会忽略一些赋值语句<ol><li>swap没有根据源映射映射在内</li><li>赋值表达式右边是常数</li><li>赋值表达式右边是存储变量，不会计算在内，因为无论顺序如何，都会分析存储变量导致的依赖性</li></ol></li><li>引入估算内存指针值的策略，内存变量永远放置在自由内存中指针上，永远不会被释放，自由指针通常是一个符号值，为了简化问题而不丧失依赖性，SGUARD会估计自由指针ptr的值，</li></ol></li><li><p>SGURAD允许用户提供额外的guide来生成特定于某些合同的修复程序，例如保护用户声明的某些关键变量</p></li></ol></li></ol></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GUARD：智能合约的漏洞检测及其修复&quot;&gt;&lt;a href=&quot;#GUARD：智能合约的漏洞检测及其修复&quot; class=&quot;headerlink&quot; title=&quot;GUARD：智能合约的漏洞检测及其修复&quot;&gt;&lt;/a&gt;GUARD：智能合约的漏洞检测及其修复&lt;/h1&gt;&lt;h1 i</summary>
      
    
    
    
    
    <category term="智能合约" scheme="http://example.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="漏洞" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="Ethereum" scheme="http://example.com/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>fabric常用命令</title>
    <link href="http://example.com/2022/05/28/fabric%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/28/fabric%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-28T08:22:15.000Z</published>
    <updated>2022-05-28T13:02:08.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><h3 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a>channel相关</h3><h4 id="获取某一channel区块信息："><a href="#获取某一channel区块信息：" class="headerlink" title="获取某一channel区块信息："></a>获取某一channel区块信息：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel getinfo -c mychannel（区块的最新高度，hash值）</span><br></pre></td></tr></table></figure><h4 id="获取最新的区块"><a href="#获取最新的区块" class="headerlink" title="获取最新的区块"></a>获取最新的区块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel fetch newest -c mychannel channel-artifacts/new.pb --orderer orderer.example.com:7050 </span><br></pre></td></tr></table></figure><h4 id="获取最新的channel配置区块"><a href="#获取最新的channel配置区块" class="headerlink" title="获取最新的channel配置区块"></a>获取最新的channel配置区块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel fetch config -c mychannel channel-artifacts/config.pb --orderer orderer.example.com:7050</span><br></pre></td></tr></table></figure><h4 id="peer加入channel"><a href="#peer加入channel" class="headerlink" title="peer加入channel"></a>peer加入channel</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b ./mychannel.genesis.block</span><br></pre></td></tr></table></figure><h4 id="查看peer已经加入的channel"><a href="#查看peer已经加入的channel" class="headerlink" title="查看peer已经加入的channel"></a>查看peer已经加入的channel</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel list</span><br></pre></td></tr></table></figure><h4 id="将pb区块转换为json"><a href="#将pb区块转换为json" class="headerlink" title="将pb区块转换为json"></a>将pb区块转换为json</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_decode --input ./channel-artifacts/new.pb --type common.Block | jq . &gt; ./channel-artifacts/new.json （将生成的区块转换成json格式）</span><br></pre></td></tr></table></figure><h4 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">configtxgen -profile TwoOrgsChannel -outputCreateChannelTx channel-artifacts/mychannel1.tx -channelID mychannel1</span><br><span class="line"></span><br><span class="line">peer channel create -o orderer.example.com:7050 -c mychannel1 -f ./channel-artifacts/mychannel1.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br><span class="line"></span><br><span class="line">peer channel join -b mychannel1.block</span><br><span class="line"></span><br><span class="line">peer channel list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建adminchannl</span><br><span class="line"></span><br><span class="line">configtxgen -profile TwoOrgsChannel -outputCreateChannelTx channel-artifacts/adminChannel.tx -channelID adminchannel</span><br><span class="line"></span><br><span class="line">peer channel create -o orderer.example.com:7050 -c adminchannel -f ./channel-artifacts/adminChannel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br><span class="line"></span><br><span class="line">peer channel join -b adminchannel.block</span><br><span class="line"></span><br><span class="line">peer channel list</span><br><span class="line"></span><br><span class="line">//创建artworkChannel</span><br><span class="line"></span><br><span class="line">configtxgen -profile TwoOrgsChannel -outputCreateChannelTx channel-artifacts/ArtWorkChannel.tx -channelID artworkchannel</span><br><span class="line"></span><br><span class="line">peer channel create -o orderer.example.com:7050 -c artworkchannel -f ./channel-artifacts/ArtWorkChannel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br><span class="line"></span><br><span class="line">peer channel join -b artworkchannel.block</span><br><span class="line"></span><br><span class="line">peer channel list</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切换peer环境变量"><a href="#切换peer环境变量" class="headerlink" title="切换peer环境变量"></a>切换peer环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span><br></pre></td></tr></table></figure><h3 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h3><h4 id="安装合约"><a href="#安装合约" class="headerlink" title="安装合约"></a>安装合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -n emr -v 1.0 -p github.com/chaincode/emr/</span><br><span class="line"></span><br><span class="line">peer chaincode install -n javabasic -l java -v 5.0 -p /opt/gopath/src/github.com/chaincode/java/</span><br></pre></td></tr></table></figure><h4 id="实例化合约"><a href="#实例化合约" class="headerlink" title="实例化合约"></a>实例化合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n emr -v 1.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;]&#125;&#x27; -P &quot;OR (&#x27;Org1MSP.peer&#x27;)&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n javabasic -v 6.0 -l java -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;]&#125;&#x27; -P &quot;OR (&#x27;Org1MSP.peer&#x27;)&quot;</span><br></pre></td></tr></table></figure><h4 id="升级合约"><a href="#升级合约" class="headerlink" title="升级合约"></a>升级合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode upgrade -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n emr -v 2.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;]&#125;&#x27; -P &quot;OR (&#x27;Org1MSP.peer&#x27;)&quot;</span><br></pre></td></tr></table></figure><h4 id="invoke合约"><a href="#invoke合约" class="headerlink" title="invoke合约"></a>invoke合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n basicinfo --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt -c &#x27;&#123;&quot;Args&quot;:[&quot;save&quot;,&quot;110115&quot;,&quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;identity\&quot;:\&quot;110115\&quot;,\&quot;mobile\&quot;:\&quot;18910012222\&quot;&#125;&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n javabasic --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt -c &#x27;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;110115&quot;,&quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;identity\&quot;:\&quot;110115\&quot;,\&quot;mobile\&quot;:\&quot;18910012222\&quot;&#125;&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n admininfo --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt -c &#x27;&#123;&quot;Args&quot;:[&quot;save&quot;,&quot;110115&quot;,&quot;&#123;&quot;202205023&quot;, &quot;&#123;\&quot;careId\&quot;:\&quot;111\&quot;,\&quot;carePassword\&quot;:\&quot;123\&quot;,\&quot;careName\&quot;:\&quot;snsnd\&quot;,\&quot;careSex\&quot;:\&quot;n\&quot;,\&quot;careAddress\&quot;:\&quot;tjut\&quot;,\&quot;carePhone\&quot;:\&quot;1351315313\&quot;,\&quot;careLive\&quot;:\&quot;xiqin\&quot;,\&quot;careUsername\&quot;:\&quot;DAMIN\&quot;&#125;&quot;&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><h4 id="查询合约"><a href="#查询合约" class="headerlink" title="查询合约"></a>查询合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">peer chaincode query -C mychannel -n javabasic -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;110115&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><h4 id="查看已安装合约"><a href="#查看已安装合约" class="headerlink" title="查看已安装合约"></a>查看已安装合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode list --installed</span><br></pre></td></tr></table></figure><h4 id="查看已经实例化合约"><a href="#查看已经实例化合约" class="headerlink" title="查看已经实例化合约"></a>查看已经实例化合约</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode list --instantiated -C mychannel</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用命令：&quot;&gt;&lt;a href=&quot;#常用命令：&quot; class=&quot;headerlink&quot; title=&quot;常用命令：&quot;&gt;&lt;/a&gt;常用命令：&lt;/h2&gt;&lt;h3 id=&quot;channel相关&quot;&gt;&lt;a href=&quot;#channel相关&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="Fabric" scheme="http://example.com/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>日用命令</title>
    <link href="http://example.com/2022/05/28/%E6%97%A5%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/28/%E6%97%A5%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-28T08:08:14.000Z</published>
    <updated>2022-05-28T08:13:54.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日用命令-更"><a href="#日用命令-更" class="headerlink" title="日用命令-更"></a>日用命令-更</h2><p>go install github.com&#x2F;nsf&#x2F;gocode@latest<br>go install github.com&#x2F;rogpeppe&#x2F;godef@latest<br>go install github.com&#x2F;golang&#x2F;lint&#x2F;golint@latest<br>go install github.com&#x2F;lukehoban&#x2F;go-find-references@latest<br>go install github.com&#x2F;lukehoban&#x2F;go-outline@latest<br>go get -u -v sourcegraph.com&#x2F;sqs&#x2F;goreturns<br>go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename@latest<br>go install github.com&#x2F;tpng&#x2F;gopkgs@latest<br>go install github.com&#x2F;newhook&#x2F;go-symbols@latest</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.26.39.171</span><br><span class="line">(./bin/server -maddr=127.0.0.1  -mport=7087 -addr= node-0 -port=7071  -latentcopilot=true  -exec=true -dreply=true) &amp; (./bin/server -maddr=127.0.0.1  -mport=7087 -addr= node-1  -port=7073   -latentcopilot=true  -exec=true -dreply=true) &amp; (./bin/server -maddr=127.0.0.1   -mport=7087 -addr= node-2 -port=7075  -latentcopilot=true  -exec=true -dreply=true) &amp; </span><br><span class="line"></span><br><span class="line">(./bin/server -maddr=127.0.0.1  -mport=7087 -addr=127.0.0.1  -port=7075  -latentcopilot=true  -exec=true -dreply=true) &amp; </span><br><span class="line">(./bin/server -maddr=127.0.0.1  -mport=7087 -addr=127.0.0.1  -port=7076  -latentcopilot=true  -exec=true -dreply=true) &amp; </span><br><span class="line">(./bin/server -maddr=127.0.0.1  -mport=7087 -addr=127.0.0.1 - port=7077  -latentcopilot=true  -exec=true -dreply=true) &amp; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(./bin/clientmain -maddr=127.0.0.1 -mport=7087 -twoLeaders=true -id=0) &amp;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">          </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 6060</span><br></pre></td></tr></table></figure><p>py代理端口导包  开vpn可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install  imbalanced-learn -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker tag hyperledger/fabric-tools:2.4 hyperledger/fabric-tools:latest</span><br><span class="line"> apt-get -y install build-essential nghttp2 libnghttp2-dev libssl-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">peer chaincode query -C mychannel -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@SnoppDogg:/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/signcerts# openssl x509 -in peer0.org1.example.com-cert.pem -noout -text</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh up -s couchdb</span><br></pre></td></tr></table></figure><p>建立文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /l %i in (0,1,9) do mkdir %i</span><br></pre></td></tr></table></figure><p>建立服务器和宿主之间的隧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L5984:127.0.0.1:5984 root@121.43.172.189</span><br></pre></td></tr></table></figure><p>调试日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f dev-peer0.org1.example.com-recordinfo-1.0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;日用命令-更&quot;&gt;&lt;a href=&quot;#日用命令-更&quot; class=&quot;headerlink&quot; title=&quot;日用命令-更&quot;&gt;&lt;/a&gt;日用命令-更&lt;/h2&gt;&lt;p&gt;go install github.com&amp;#x2F;nsf&amp;#x2F;gocode@latest&lt;br&gt;g</summary>
      
    
    
    
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>数字藏品管理平台（一）</title>
    <link href="http://example.com/2022/05/28/%E6%95%B0%E5%AD%97%E8%97%8F%E5%93%81%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0(%E4%B8%80)/"/>
    <id>http://example.com/2022/05/28/%E6%95%B0%E5%AD%97%E8%97%8F%E5%93%81%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0(%E4%B8%80)/</id>
    <published>2022-05-28T07:47:48.000Z</published>
    <updated>2022-05-28T07:54:19.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字藏品管理平台"><a href="#数字藏品管理平台" class="headerlink" title="数字藏品管理平台"></a>数字藏品管理平台</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ol><li>数字藏品管理平台，是指使用区块链技术，对特定的作品、艺术品生成唯一数字凭证，制作成区块链数字藏品，用以数字化发行、收藏和使用。简单说，就是每份数字藏品都拥有唯一的“身份证”，利用分布式的储存技术，可以给客户提供很多新的创意价值。且数字藏品都具有独有性、稀缺性。因此，数字藏品也可以说是一种有收藏价值的虚拟产品。</li><li>该平台数字藏品跟国外的nft数字藏品不同，该平台数字藏品主要用于收藏和自我观赏为主，通过区块链技术有效解决艺术品数字形态的唯一性、真实性和永久性，实现了确权与溯源的能力，在增强了艺术品的流动性的同时且无法被复制和随意纂改。</li></ol><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>藏品在平台的确权问题 ：</p><ol><li>现实中的藏品在是唯⼀的，只是⼀件件物体，确权较为繁琐，⽆法满⾜数量较多，传播较快的 需求，对应到数字藏品，将数字作品上链，利⽤区块链的透明账本和不可篡改的特征，及其可 溯源等，⽣成数字作品的“身份证”，其版权将会得到在链上得到承认，解决确权问题，实现数 字作品和作者之间的唯⼀确定关系，减少确权维权成本。 </li><li>功能：平台在区块链共识机制下，单个节点⽆法对信息作出修改。要实现修改必须动⽤系统内 ⾄少51%的算⼒，篡改成本过⾼，可⾏性极低，由此可充分保障链上数字内容的不可篡改性。 同时借助区块链技术对数字作品进⾏确权时，可以减少传统作品版权申请、注册和登记的周期 与成本，可以为数字作品的创作者提供充分的便利性和创造更⾼的满意度。 </li><li>展望：平台可以为数字作品的保护提供链上的存证，但可能⽆法保证该⽤户上链的作品是否为 符合著作权法的合法原创作品，也⽆法识别原创作者的身份，⽆法辨别侵权与否，⾃⼰暂时的 想法是对上链的作品进⾏数字图像特征的提取，将作品和该作品特征都上链，将数字作品与原 创作者进⾏唯⼀绑定，相当于实现异于区块链本身对该作品⽣成的哈希值以外的作品版权确 认，确定链上的作品本质与作者映射的关系</li></ol><h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><ol><li><p>目前构想的三层架构：</p><ol><li>区块链网络：使用hyperledge-fabric搭建，在目前fabric支持的数据库中，采用<strong>CouchDB</strong>用来存放块数据</li><li>缓存层：Redis，可以将常用的平台数据存储到Redis，加快部分数据的查询速度</li><li>业务层逻辑层Dapp：使用Java开发，前后端技术采用springboot，vue，在Java项目代码中通过FabricSDK与搭建的Fabric网络进行交互（触发合约）。</li></ol></li><li><p>区块链网络搭建：</p><ol><li>基于阿里云服务器：Linux Ubuntu（10.04）搭建fabric网络，部署节点</li><li>fabric智能合约的开发采用go，并运行在容器当中</li></ol></li><li><p>区块链基础框架：fabric1.4.0</p></li></ol><h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><ol><li>在服务器上准备基础环境：包括fabric网络的搭建，单机部署运行；redis坏境搭建</li><li>Dapp开发环境：IDEA、XShell 、Xftp、jdk1.8 、go1.12（后续项目实现可能有变动）</li><li>运行启动：null</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字藏品管理平台&quot;&gt;&lt;a href=&quot;#数字藏品管理平台&quot; class=&quot;headerlink&quot; title=&quot;数字藏品管理平台&quot;&gt;&lt;/a&gt;数字藏品管理平台&lt;/h1&gt;&lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Fabric" scheme="http://example.com/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥-算法题-1</title>
    <link href="http://example.com/2022/04/03/p1/"/>
    <id>http://example.com/2022/04/03/p1/</id>
    <published>2022-04-03T15:38:24.000Z</published>
    <updated>2022-04-03T16:16:26.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Q-1"><a href="#Q-1" class="headerlink" title="Q_1:"></a>Q_1:</h1><p>【问题描述】<br>   你有一架天平。现在你要设计一套砝码，使得利用这些砝码可以称出任意小于等于 N 的正整数重量。<br>   那么这套砝码最少需要包含多少个砝码？<br>   注意砝码可以放在天平两边。</p><p>【输入格式】<br>输入包含一个正整数 N。</p><p>【输出格式】<br>输出一个整数代表答案。</p><p>【样例输入】<br>7</p><p>【样例输出】<br>3</p><p>【样例说明】<br>3 个砝码重量是 1、4、6，可以称出 1 至 7 的所有重量。<br>1 &#x3D; 1；<br>2 &#x3D; 6 − 4 (天平一边放 6，另一边放 4)；<br>3 &#x3D; 4 − 1；<br>4 &#x3D; 4；<br>5 &#x3D; 6 − 1；<br>6 &#x3D; 6；<br>7 &#x3D; 1 + 6；</p><p>少于 3 个砝码不可能称出 1 至 7 的所有重量。解析<br>结果应该是最少的砝码数量<br>首先，如果要称的重量为1的话，只能选择重量为1的砝码，1是必选的一个砝码。</p><p>然后再称比1重的，反正都是要再加砝码，那我们为何不选一个能称的重量尽可能大的呢。类似于贪心算法<br>选1、2的砝码可以满足1&#x3D;1，2&#x3D;2，1+2&#x3D;3<br>选1、3的砝码可以满足1&#x3D;1，2&#x3D;3-1，3&#x3D;3，4&#x3D;3+1<br>选1、4的砝码可以满足1&#x3D;1，2&#x3D;？无法称2，不合题意<br>因此我们选择的砝码组合是1、3，此时我们可以称的最大重量为4</p><p>当我们还需要再增加砝码时<br>同理可得<br>选1、3、9的组合可以满足小于等于13（13&#x3D;1+3+9）的所有重量</p><p>从中可以发现一个规律，当我们需要第三个砝码是，前两个砝码（1、3）满足的最大重量已经是4了，下一个要满足的重量是5，我们遵循砝码尽可能大的原则，选择的第三个砝码的重量满足的条件是：它减去 已经可以称得的最大重量 可以得到 下一个需要称的重量。也就是weight - 4 &#x3D; 5，可得weight为9。</p><p>以上为<a href="https://blog.csdn.net/Striver00/article/details/116031667">(160条消息) 第十二届蓝桥杯省赛JavaB组 试题 G: 最少砝码_小小风0的博客-CSDN博客_最少砝码java</a></p><p>自己的理解：我们由已经拥有的砝码可以得出可以称出的重量范围，当到最大的重量不在能称出需要的重量的时，我们就用想称出的下一个重量加上现在已经能够称出的最大重量，类似于贪心算法，选一个最大的。</p><p>再往下推，可以得到下面的表格</p><table><thead><tr><th>砝码序号</th><th>砝码重量</th><th>总重量(可称出的最大重量)</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>9</td><td>13</td></tr><tr><td>4</td><td>27</td><td>40</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>count&#x3D;count+1</td><td>weight&#x3D;weight*3</td><td>total&#x3D;total+weight</td></tr></tbody></table><p>得到规律：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count++;<span class="comment">//count=count+1</span></span><br><span class="line">weight*=<span class="number">3</span>;<span class="comment">//weight=weight*3</span></span><br><span class="line">total+=weight;<span class="comment">//total=total+weight</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WPPStart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PROJECT</span>_NAME:javaPUPU</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2022-04-03-22:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DESCRIPTION</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class 砝码统计 &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            sc.close();</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (total &lt; n) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                weight *= <span class="number">3</span>;</span><br><span class="line">                total += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="Q-2"><a href="#Q-2" class="headerlink" title="Q_2"></a>Q_2</h1><p>【问题描述】给定一个长度为 N<em>N</em> 的数列，A_1, A_2, \cdots A_N<em>A</em>1,<em>A</em>2,⋯<em>A**N</em>，如果其中一段连续的子序列 A_i,A_i+1, \cdots A_j<em>A**i</em>,<em>A**i</em>+1,⋯<em>A**j</em> ( i \leq j<em>i</em>≤<em>j</em> ) 之和是 K<em>K</em> 的倍数，我们就称这个区间 [i, j][<em>i</em>,<em>j</em>] 是 K 倍区间。</p><p>你能求出数列中总共有多少个 K<em>K</em> 倍区间吗？</p><p>【输入格式】第一行包含两个整数 N<em>N</em> 和 K<em>K</em>( 1 \leq N,K \leq 10^51≤<em>N</em>,<em>K</em>≤105 )。</p><p>以下 N 行每行包含一个整数 A_i<em>A**i</em> ( 1 \leq A_i \leq 10^51≤<em>A**i</em>≤105 )。</p><p>【输出格式】<br>输出一个整数，代表 K 倍区间的数目。</p><p>【样例输入】<br>5  2 </p><p> 1</p><p> 2</p><p> 3</p><p> 4</p><p> 5</p><p>【样例输出】<br>6</p><p><strong>题目思路</strong><br>　　求区间[l,r]的和是k的倍数的个数。求区间和，我们可以通过前缀和来求出。我们规定sum[i]表示第1个元素到第i个元素的和。那么sum[r] - sum[l-1]就是区间[l,r]的和。区间[l,r]的和是k的倍数即**(sum[r] - sum[l-1])%k &#x3D;&#x3D; 0 即sum[r]%k &#x3D;&#x3D; sum[l-1]%k**<br>　　那么，我们求出每个前缀和，在求的过程中取模，两个相等的前缀和就能组成一个k倍区间。我们可以在计算完前缀和以后，使用两层for循环来计数k倍区间的个数。但是由于数据量较大，这样是会超时的。那么我们是否能在计算前缀和的过程中来记录k倍区间的个数呢？<br>我们用一个数组cnt[i]表示当前位置之前，前缀和取模后等于i的个数。举个例子：<br>　　数列 1 2 3 4 5  mod &#x3D; 2<br>　　对前1个数的和取模， 为1 之前有0个前缀和取模后为1，个数+0<br>　　对前2个数的和取模， 为1 之前有1个前缀和取模后为1，个数+1<br>　　对前3个数的和取模， 为0 之前有0个前缀和取模后为0, 个数+0<br>　　对前4个数的和取模， 为0 之前有1个前缀和取模后为0，个数+1<br>　　对钱5个数的和取模， 为1 之前有2个前缀和取模后为1，个数+2<br>　　到目前为止ans &#x3D; 4。但是ans应该等于6，因为这样计算后，我们漏掉了前i个数的和取模是k的倍数的情况，即[0,i]区间和是k的倍数，因此，我们要在ans &#x3D; 4 的基础上 加上前缀和取模后为0的个数 即ans+2 &#x3D; 6;</p><p><strong>上面的题解看懂的话，就不用看下面的这部分了。下面是用自己的话转化成自己的理解，也方便自己在以后重新翻阅博客的时候，能够快速重新学习。</strong><br>　　举个简单的例子，比如测试样例为：<br>　　6 3</p><p>　　1 3 4 5 8 9<br>　　那么正确的答案应该是6。前缀和的解题思想主要就是再遍历输入数据的时候，把数组的前缀和%k（为什么要对k取余，上面的解题思路就写的很好理解）之后保存到数组sum里面，那么 1 3 4 5 8 9，取完前缀和并%k之后就是 1 1 2 1 0 0。数组中的后面两个0，不难理解就是前缀和%k为0的组合，也就是说，sum[i] &#x3D;&#x3D; 0的，都是满足条件的。接下来再统计相同sum[i]的组合。相同sum[i]的意思就是在求的过程中取模，两个相等的前缀和就能组成一个k倍区间。比如前两个1之间，sum[r]-sum[l-1]之间的数%k&#x3D;&#x3D;0（就是3%3&#x3D;&#x3D;0）。所以用另外的一个数组cnt来保存同样的sum[i]的个数值，用ans一直递加sum[i]相同个数的组合，后面再加上cnt<a href="h:%25k==0">0</a>的个数就是答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WPPStart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PROJECT</span>_NAME:javaPUPU</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2022-04-03-22:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DESCRIPTION</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">k</span>倍区间 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner input=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=input.nextInt();</span><br><span class="line">        <span class="type">int</span> K=input.nextInt();</span><br><span class="line">        <span class="type">int</span> count[]=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">1000001</span>];</span><br><span class="line">        <span class="type">int</span> arr[]=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> s[]=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            arr[i]=input.nextInt();</span><br><span class="line">            s[i]=s[i-<span class="number">1</span>]+arr[i];    <span class="comment">//计算前缀和</span></span><br><span class="line">            s[i]%=K;      <span class="comment">//在这里直接对前缀和取摸</span></span><br><span class="line">        &#125;</span><br><span class="line">        count[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> anscount=<span class="number">0</span>;  <span class="comment">//int 会爆掉</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            anscount+=count[s[i]];<span class="comment">//除了count[0]=1,其余的初始值都为0，</span></span><br><span class="line">            count[s[i]]++;       <span class="comment">//如果出现过一次后加1，出现过两次及以上，anscount++,</span></span><br><span class="line">            <span class="comment">//我们就是要找总共有多少对,</span></span><br><span class="line">            <span class="comment">//只出现一次虽然count[i]加1但总的答案不会加</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(anscount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Q-1&quot;&gt;&lt;a href=&quot;#Q-1&quot; class=&quot;headerlink&quot; title=&quot;Q_1:&quot;&gt;&lt;/a&gt;Q_1:&lt;/h1&gt;&lt;p&gt;【问题描述】&lt;br&gt;   你有一架天平。现在你要设计一套砝码，使得利用这些砝码可以称出任意小于等于 N 的正整数重量。&lt;br&gt; </summary>
      
    
    
    
    
    <category term="algorithm" scheme="http://example.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>copilot协议</title>
    <link href="http://example.com/2022/03/28/copilot%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2022/03/28/copilot%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-03-28T10:45:17.000Z</published>
    <updated>2022-05-28T12:59:01.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="paper概述"><a href="#paper概述" class="headerlink" title="paper概述"></a>paper概述</h2><p>​        理解了这个slowdown- tolerance 在这个协议中RSM里面的执行逻辑，这是我的理解：在这个共识协议中将其一个leader替换为两个pilot和copilot，执行类似于paxos的选举机制选出两个new pilot来保证RSM的效率较快，client会同时发commands给这两个pilot，有一些在log entries里面的相互依赖和规则支持他们线性执行，如果一个pilot等待太长时间就会由另外一个copilot去fast takeover，当一个pilot挂掉以后，也会执行类似于paxos的选举去选举new pilot去代替挂掉的那个pilot，这样在存在slow的replicas时，会有一定的slowdown tolerance去保证其相比于Multi-Paxos、EPaxos等有一定效率上的提升。</p><h2 id="slowdown"><a href="#slowdown" class="headerlink" title="slowdown"></a>slowdown</h2><p>​    <strong>copilot慢速容忍协议</strong>，首先对slowdown 进行明确的定义。要定义一个节点的处理速度。一个节点从收到一条消息开始，到其处理这条消息完毕，将回复送出为止，这段时间的长短就是一个节点的处理速度。这段时间不包含消息在网络链路上的传输时间，仅包含消息在节点本机处理所需的时间。</p><p>​        假设一个节点处理一条消息的典型时间为 1ms，而设置超时阈值 <code>t</code> &#x3D; 10ms，那么如果该节点处理一条消息花费了大于等于 11ms，就说明该节点出现了 slowdown。出错（failed）的节点一定是 slowdown 的，但 slowdown 的节点不一定 failed——它只是响应速度变慢，而不是停止响应。</p><h2 id="为什么现有的共识协议无法容忍-slowdown"><a href="#为什么现有的共识协议无法容忍-slowdown" class="headerlink" title="为什么现有的共识协议无法容忍 slowdown"></a>为什么现有的共识协议无法容忍 slowdown</h2><p>​        一个分布式状态机系统在处理一条客户端指令时，如果在处理过程中的任意时间点，只有一条路径可走，那么该系统就存在“单点故障”的可能性——在这点处负责处理的节点发生 slowdown 会影响整个节点的处理速度。</p><h1 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h1><ol><li><p>Copilot还是一个类Paxos的一个分布式协议，其特点在于Copilot具有slowdown-tolerance的特性，其内部实现最终避免了高延迟。尽管存在一个慢速的副本，但仍然能够提供正常服务，实现具有slowdown-tolerance的RSM的第一步。</p></li><li><p>Copilot的提供slowdown-tolerance的必须能够提供的是client在四个阶段的慢速容忍，即如下四个阶段：</p><ol><li>Receive</li><li>Order：</li><li>Execute</li><li>Reply</li></ol><p>它使用了两个distinguished的replicas的来并行处理完成客户端的命令（pilot和copilot），Copilot被允许来   <em><strong>fast takeove</strong>r</em>  一个slow的pilot，Copilot 使用依赖关系组合日志     <em><strong>preAcceptDeps[] [][]    int32</strong></em>  ,   <em><strong>Instance.Deps[]</strong></em>     ,Copilot有两个phase，：</p><p>FastAccept:在该阶段如果多数的replicas同意pilot的排序，就提交到该fast阶段，pilot继续执行</p><p>Accept:若已经同意另一个pilot提出的不同顺序，pilot则会同意副本建议的依赖关系。（line:2908  <em><strong>handleTryPreAcceptReply</strong></em>()）</p></li><li><p>Copilot的两项优化：</p><ol><li>ping-pong batching：便于他们交替他们的建议，允许两个飞行员都致力于快速path</li><li>null dependency elimination：空依赖消除允许快速飞行员避免等待来自慢速飞行员的提交</li></ol><h2 id="Slowdown-Tolerance"><a href="#Slowdown-Tolerance" class="headerlink" title="Slowdown Tolerance"></a>Slowdown Tolerance</h2></li><li><p>采用viewchange来轮换leader，如何检测leader的减速，有两种机制即：</p><ul><li>根据过去throughput的峰值性能表现来逐渐增大leader的throughput的上下限：</li></ul><p><em><strong>clientol&#x2F;client.go processAndPrintThroughputs</strong></em>  ？</p><ul><li>每个peer之间不会超过heartbeat timeout,以确保领导者提出新批次的速度足够快</li></ul><p><em><strong>copilot.go  BeaconChan</strong></em></p><p>​    如果吞吐量低于下限或者超过了heartbeat timeout都会导致<em><strong>view change</strong></em>    来轮换副本中的leader ,</p></li><li><p><strong>Preparation for the beginning：</strong></p><img src="https://s2.loli.net/2022/05/28/osyfb1Bl89EQNu5.png" alt="image-20220315134306082" style="zoom: 80%;" /><p>在    <em><strong>ConnectToPeers()</strong></em>   中构建  PeerReaders   和   PeerWriters   时用了bufio，将要写入的数据存入缓冲区，然后一次性将数据写入文件。每次我们想读取文件内容时，会首先从缓冲区读取，提高了读取速度，也避免了频繁的 文件IO，</p><p><img src="https://s2.loli.net/2022/05/28/UrgxDXGWdsRLlQc.jpg" alt="bufio.Reader结构"></p></li></ol><p>Copilot 的 ordering 协议将command放入到  pilot log 和  copilot log 中，执行协议使用 Pilot 和 copilot 日志之间的最终依赖关系和一个优先级规则来构建单个组合日志，该优先级规则在 copilot 条目之前的一个循环中对 Pilot 条目进行排序。</p><ol><li><p>Copilot实现的Ordering协议完成的事：</p><ul><li>q日志条目的命令和 log entry 持久保存到副本stable storage</li><li>在多达 f 个副本（包括两个 Pilot）失败时可以恢复它们  <em><strong>instancesToRecover</strong></em></li></ul></li><li><p>client对两个pilot   都会发出commands</p></li><li><p>pilot  propose  command和 init dependency，在收到client发来的命令时，在<em><strong>r.handlePropose()</strong></em>     中pilot 将command放入到下一个可用的log  entry中</p><ul><li><img src="https://s2.loli.net/2022/05/28/7voqNZVm4iWEdrL.png"></li><li><img src="https://s2.loli.net/2022/05/28/eXLKDF4usPzvdRa.png" alt="image-20220316110800849" style="zoom: 33%;" />·                   兼容性检查</li></ul></li><li><p>一旦 entry 被committed 并且之前的所有排序过的entries都被执行 副本才会 execute a command</p><h1 id="slowdown机制"><a href="#slowdown机制" class="headerlink" title="slowdown机制"></a>slowdown机制</h1><p><img src="https://s2.loli.net/2022/05/28/pPObf6Fx21dg4jD.png" alt="viewchange (1)"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;paper概述&quot;&gt;&lt;a href=&quot;#paper概述&quot; class=&quot;headerlink&quot; title=&quot;paper概述&quot;&gt;&lt;/a&gt;paper概述&lt;/h2&gt;&lt;p&gt;​        理解了这个slowdown- tolerance 在这个协议中RSM里面的执行逻辑</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="一致性协议" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="论文笔记" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04安装部署Fabric v1.4.0 — 单机部署</title>
    <link href="http://example.com/2022/03/28/Ubuntu20.04%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Fabric%20v1.4.0%20%E2%80%94%20%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2022/03/28/Ubuntu20.04%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Fabric%20v1.4.0%20%E2%80%94%20%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/</id>
    <published>2022-03-28T10:21:03.000Z</published>
    <updated>2022-05-28T08:26:27.317Z</updated>
    
    <content type="html"><![CDATA[<pre><code>总体来说还是得遇到点坑，自己装会熟练很多，很多问题在遇到解决完以后就更容易理解了</code></pre><h2 id="一、环境安装"><a href="#一、环境安装" class="headerlink" title="一、环境安装"></a>一、环境安装</h2><h3 id="1-Docker和Docker-Compose安装"><a href="#1-Docker和Docker-Compose安装" class="headerlink" title="1. Docker和Docker Compose安装"></a>1. Docker和Docker Compose安装</h3><p><a href="https://www.docker.com/get-started">Docker</a> : 17.06.2-ce及其以上版本，Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口<br><a href="https://docs.docker.com/compose/overview/">Docker Compose</a> : 1.14.0及其以上版本，使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</p><p>1.1 安装Docker(参考<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Get Docker CE for Ubuntu</a>)</p><p>由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker-ce docker.io</span><br></pre></td></tr></table></figure><p>更新apt包索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装软件包以允许apt通过HTTPS使用存储库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure><p>添加Docker官方的GPG密钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>使用下面的命令来设置stable存储库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure><p>再更新一下apt包索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装最新版本的Docker CE：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此步骤耗时</span></span><br><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure><p>验证docker,查看docker服务是否启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>若未启动，则启动docker服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>经典的hello world：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>1.2 安装Docker Compose</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Docker Compose二进制文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!下载特别慢  后来下载速度为0</span></span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备用：curl -L https://get.daocloud.io/docker/compose/releases/download/1.23.2/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span> </span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-Go安装"><a href="#2-Go安装" class="headerlink" title="2. Go安装"></a>2. Go安装</h3><p><a href="https://golang.org/dl/">Go</a> : 1.11.x，Fabric系统是用Go语言开发的，编译Fabric需要Go环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载go1.11.linux-amd64.tar.gz并将其解压到指定目录（此处为/usr/local）</span></span><br><span class="line">wget https://studygolang.com/dl/golang/go1.11.linux-amd64.tar.gz</span><br><span class="line">tar xzvf go1.11.linux-amd64.tar.gz -C /usr/local</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建<span class="variable">$GOPATH</span></span></span><br><span class="line">mkdir /home/ubuntu</span><br><span class="line">mkdir /home/ubuntu/gopath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑/etc/profile文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件内容如下所示：</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOARCH=amd64</span><br><span class="line">export GOOS=linux</span><br><span class="line">export GOPATH=/home/ubuntu/gopath</span><br><span class="line">export GOBIN=$GOPATH/bin</span><br><span class="line">export PATH=$GOPATH/bin:$GOROOT/bin:$PATH</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使环境变量生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看gobanben</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure><h3 id="3-host文件配置"><a href="#3-host文件配置" class="headerlink" title="3. host文件配置"></a>3. host文件配置</h3><p>因为Fabric节点通信中不支持使用ip进行访问，所以只能修改host映射区块链网络的域名example.com。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1        orderer.example.com peer0.org1.example.com peer1.org1.example.com peer0.org2.example.com peer1.org2.example.com</span><br></pre></td></tr></table></figure><h2 id="二、Fabric在线安装"><a href="#二、Fabric在线安装" class="headerlink" title="二、Fabric在线安装"></a>二、Fabric在线安装</h2><p><strong>以下所有操作使用root用户操作</strong>，如果没有root账户需要手动启用。</p><h3 id="1-下载fabric-samples源文件"><a href="#1-下载fabric-samples源文件" class="headerlink" title="1. 下载fabric-samples源文件"></a>1. 下载fabric-samples源文件</h3><p>将fabric-samples下载到<code>$GOPATH/src/github.com/hyperledger</code>目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/github.com/hyperledger</span><br><span class="line">cd $GOPATH/src/github.com/hyperledger</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆fabric-samples项目并切换到v1.4tag</span></span><br><span class="line">git clone https://github.com/hyperledger/fabric-samples.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备用 ： https://gitee.com/hbuzzs/fabric-samples.git</span></span><br><span class="line">cd fabric-samples</span><br><span class="line">git checkout -b sample v1.4.0</span><br></pre></td></tr></table></figure><h3 id="2-手动安装Fabric-Binaries和Fabric相关的Docker镜像"><a href="#2-手动安装Fabric-Binaries和Fabric相关的Docker镜像" class="headerlink" title="2. 手动安装Fabric Binaries和Fabric相关的Docker镜像"></a>2. 手动安装Fabric Binaries和Fabric相关的Docker镜像</h3><p>将指定版本的Hyperledger Fabric特定于平台的二进制文件和配置文件安装到fabric-samples的bin和config目录中</p><p>下载压缩包文件上传到Ubuntu</p><ul><li><a href="https://www.123pan.com/s/XkRRVv-6uIk3">hyperledger-fabric-linux-amd64-1.4.0.tar.gz</a></li><li><a href="https://www.123pan.com/s/XkRRVv-yuIk3">hyperledger-fabric-ca-linux-amd64-1.4.0.tar.gz</a></li></ul><p>接着切换到压缩包所在目录执行解压命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf hyperledger-fabric-linux-amd64-1.4.0.tar.gz -C $GOPATH/src/github.com/hyperledger/fabric-samples/</span><br><span class="line">tar xzvf hyperledger-fabric-ca-linux-amd64-1.4.0.tar.gz -C $GOPATH/src/github.com/hyperledger/fabric-samples/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向/etc/profile中写入环境变量</span></span><br><span class="line">sudo echo &#x27;export PATH=$GOPATH/src/github.com/hyperledger/fabric-samples/bin:$PATH&#x27; &gt;&gt; /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使环境变量生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>下载相关Docker镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Fabric相关镜像（fabric-peer、fabric-orderer、fabric-ccenv、fabric-tools）</span></span><br><span class="line">docker pull hyperledger/fabric-peer:1.4.0</span><br><span class="line">docker tag hyperledger/fabric-peer:1.4.0 hyperledger/fabric-peer:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------------------------------------------</span></span><br><span class="line">docker pull hyperledger/fabric-orderer:1.4.0</span><br><span class="line">docker tag hyperledger/fabric-orderer:1.4.0 hyperledger/fabric-orderer:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------------------------------------------</span></span><br><span class="line">docker pull hyperledger/fabric-ccenv:1.4.0</span><br><span class="line">docker tag hyperledger/fabric-ccenv:1.4.0 hyperledger/fabric-ccenv:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------------------------------------------</span></span><br><span class="line">docker pull hyperledger/fabric-tools:1.4.0</span><br><span class="line">docker tag hyperledger/fabric-tools:1.4.0 hyperledger/fabric-tools:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Fabric第三方镜像（fabric-couchdb、fabric-kafka、fabric-zookeeper）</span></span><br><span class="line">docker pull hyperledger/fabric-couchdb:0.4.14</span><br><span class="line">docker tag hyperledger/fabric-couchdb:0.4.14 hyperledger/fabric-couchdb:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------------------------------------------</span></span><br><span class="line">docker pull hyperledger/fabric-kafka:0.4.14</span><br><span class="line">docker tag hyperledger/fabric-kafka:0.4.14 hyperledger/fabric-kafka:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------------------------------------------</span></span><br><span class="line">docker pull hyperledger/fabric-zookeeper:0.4.14</span><br><span class="line">docker tag hyperledger/fabric-zookeeper:0.4.14 hyperledger/fabric-zookeeper:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Fabric CA镜像</span></span><br><span class="line">docker pull hyperledger/fabric-ca:1.4.0</span><br><span class="line">docker tag hyperledger/fabric-ca:1.4.0 hyperledger/fabric-ca:latest</span><br></pre></td></tr></table></figure><h3 id="3-通过运行Build-your-first-network样例来进行测试"><a href="#3-通过运行Build-your-first-network样例来进行测试" class="headerlink" title="3. 通过运行Build your first network样例来进行测试"></a>3. 通过运行Build your first network样例来进行测试</h3><p>启动网络验证是否正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $GOPATH/src/github.com/hyperledger/fabric-samples/first-network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动方式一：编译通过Golang开发的chaincode并启动相关的容器</span></span><br><span class="line">./byfn.sh up</span><br></pre></td></tr></table></figure><p>验证正常后关闭网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $GOPATH/src/github.com/hyperledger/fabric-samples/first-network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭Fabric方式一：停止first-network网络中所有的容器，删除crypto材料和4个artifacts（genesis.block、mychannel.block、Org1MSPanchor.tx、Org2MSPanchor.tx）以及chaincode镜像</span></span><br><span class="line">./byfn.sh down</span><br></pre></td></tr></table></figure><h3 id="4-测试通过后通过docker-compose启动"><a href="#4-测试通过后通过docker-compose启动" class="headerlink" title="4. 测试通过后通过docker-compose启动"></a>4. 测试通过后通过docker-compose启动</h3><p>第一次执行需要初始化证书文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $GOPATH/src/github.com/hyperledger/fabric-samples/first-network</span><br><span class="line">./byfn.sh generate</span><br></pre></td></tr></table></figure><p>启动网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd $GOPATH/src/github.com/hyperledger/fabric-samples/first-network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动order、peer、ca节点</span></span><br><span class="line">docker-compose -f docker-compose-e2e.yaml up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动cli节点</span></span><br><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建通道和部署测试合约（如果执行过就不用再执行了）</span></span><br><span class="line">docker exec cli scripts/script.sh mychannel 3 golang 10 false</span><br></pre></td></tr></table></figure><p>关闭网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $GOPATH/src/github.com/hyperledger/fabric-samples/first-network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭order、peer、ca节点</span></span><br><span class="line">docker-compose -f docker-compose-e2e.yaml down</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭cli节点</span></span><br><span class="line">docker-compose -f docker-compose-cli.yaml down</span><br></pre></td></tr></table></figure><ol><li><p>​    前面基本没有什么好说的，按照博主的步骤一步一步来会好很多，别自己跳步骤。</p></li><li><p>在用bootstrap.脚本安装脚本大多数情况会出错，就需要我们自己手动来完成bootstrap的几项工作，即bootstrap.sh帮我们干了什么事：</p><ol><li>如果在当前目录中没有 <code>hyperledger/fabric-samples</code>，则从 <code>github.com</code> 克隆 <code>hyperledger/fabric-samples</code> 存储库</li><li>使用 <code>checkout</code> 签出对应指定的版本标签</li><li>将指定版本的Hyperledger Fabric平台特定的二进制文件和配置文件安装到 <code>fabric-samples</code> 存储库的根目录中</li><li>下载指定版本的 <code>Hyperledger Fabric docker</code> 镜像文件</li><li>将下载的 docker 镜像文件标记为 “latest”</li></ol></li><li><p>首先将二进制文件和配置文件安装到fabric-samples的bin和config目录中，按照博主的给的链接下载，传到自己的运行主机当中，解压到$GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;中即可。注意在下载相关Docker镜像的时候版本要与sample的所需的版本一致，版本不一致会导致链接不成功，拉取镜像后都要进行重命名：latest，如此操作。每次重新启动网络时，都要<code>./byfn.sh down</code>删除所有数据，然后再启动网络。</p></li><li><p>到最后可能有一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: error getting chaincode deployment spec for mycc: error getting chaincode package bytes: failed to calculate dependencies: incomplete package: github.com/hyperledger/fabric/core/chaincode/shim</span><br><span class="line">!!!!!!!!!!!!!!! Chaincode installation on peer0.org1 has failed !!!!!!!!!!!!!!!!</span><br><span class="line">========= ERROR !!! FAILED to execute End-2-End Scenario ===========</span><br></pre></td></tr></table></figure><p>跟脚本代码是从（<a href="https://github.com/hyperledger/fabric-samples/blob/1343ccb6282e4ecab23ccdba0d1b2158cf7dfd55/first-network/scripts/utils.sh#L126">github</a>）以下逻辑报出的，意思讲以下依赖未找到（<a href="https://github.com/hyperledger/fabric-samples/blob/1343ccb6282e4ecab23ccdba0d1b2158cf7dfd55/chaincode/chaincode_example02/go/chaincode_example02.go#L29">github</a>），或许是仓库分支代码，<code>release-1.4</code>是有的，最新的<code>master</code>分支已经删掉了，可以考虑更新下新版的依赖，但是后来感觉也不是这个问题。。。。,可以参考<a href="https://www.bcskill.com/index.php/archives/925.html%EF%BC%8C%E6%9C%80%E5%90%8E%E6%88%91%E6%B2%A1%E6%9C%89%E6%8D%A2%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%9C%A8%E5%8D%9A%E4%B8%BB%E5%B8%AE%E5%8A%A9%E4%B8%8B%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%98%AFdocker">https://www.bcskill.com/index.php/archives/925.html，最后我没有换依赖，在博主帮助下，发现是docker</a> 镜像版本的问题，修改后配置成功了，遇到问题检查下前面的步骤有没有和文中一致，祝你好运！</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;总体来说还是得遇到点坑，自己装会熟练很多，很多问题在遇到解决完以后就更容易理解了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;一、环境安装&quot;&gt;&lt;a href=&quot;#一、环境安装&quot; class=&quot;headerlink&quot; title=&quot;一、环境安装&quot;&gt;&lt;/a&gt;一、</summary>
      
    
    
    
    
    <category term="Fabric" scheme="http://example.com/tags/Fabric/"/>
    
  </entry>
  
</feed>
